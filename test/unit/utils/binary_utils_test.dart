import 'package:flutter_test/flutter_test.dart';
import 'package:mrumru/src/utils/binary_utils.dart';

void main() {
  group('Test of BinaryUtils.convertBinaryToAscii()', () {
    test('Should parse each 8-bit binary into ASCII letters', () {
      // @formatter:off
      // Arrange
      List<String> actualBinaryList = <String>[
        '00000001', '00000010', '00000011', '00000100', '00000101', '00000110', '00000111', '00001000',
        '00001001', '00001010', '00001011', '00001100', '00001101', '00001110', '00001111', '00010000',
        '00010001', '00010010', '00010011', '00010100', '00010101', '00010110', '00010111', '00011000',
        '00011001', '00011010', '00011011', '00011100', '00011101', '00011110', '00011111', '00100000',
        '00100001', '00100010', '00100011', '00100100', '00100101', '00100110', '00100111', '00101000',
        '00101001', '00101010', '00101011', '00101100', '00101101', '00101110', '00101111', '00110000',
        '00110001', '00110010', '00110011', '00110100', '00110101', '00110110', '00110111', '00111000',
        '00111001', '00111010', '00111011', '00111100', '00111101', '00111110', '00111111', '01000000',
        '01000001', '01000010', '01000011', '01000100', '01000101', '01000110', '01000111', '01001000',
        '01001001', '01001010', '01001011', '01001100', '01001101', '01001110', '01001111', '01010000',
        '01010001', '01010010', '01010011', '01010100', '01010101', '01010110', '01010111', '01011000',
        '01011001', '01011010', '01011011', '01011100', '01011101', '01011110', '01011111', '01100000',
        '01100001', '01100010', '01100011', '01100100', '01100101', '01100110', '01100111', '01101000',
        '01101001', '01101010', '01101011', '01101100', '01101101', '01101110', '01101111', '01110000',
        '01110001', '01110010', '01110011', '01110100', '01110101', '01110110', '01110111', '01111000',
        '01111001', '01111010', '01111011', '01111100', '01111101', '01111110', '01111111', '10000000',
        '10000001', '10000010', '10000011', '10000100', '10000101', '10000110', '10000111', '10001000',
        '10001001', '10001010', '10001011', '10001100', '10001101', '10001110', '10001111', '10010000',
        '10010001', '10010010', '10010011', '10010100', '10010101', '10010110', '10010111', '10011000',
        '10011001', '10011010', '10011011', '10011100', '10011101', '10011110', '10011111', '10100000',
        '10100001', '10100010', '10100011', '10100100', '10100101', '10100110', '10100111', '10101000',
        '10101001', '10101010', '10101011', '10101100', '10101101', '10101110', '10101111', '10110000',
        '10110001', '10110010', '10110011', '10110100', '10110101', '10110110', '10110111', '10111000',
        '10111001', '10111010', '10111011', '10111100', '10111101', '10111110', '10111111', '11000000',
        '11000001', '11000010', '11000011', '11000100', '11000101', '11000110', '11000111', '11001000',
        '11001001', '11001010', '11001011', '11001100', '11001101', '11001110', '11001111', '11010000',
        '11010001', '11010010', '11010011', '11010100', '11010101', '11010110', '11010111', '11011000',
        '11011001', '11011010', '11011011', '11011100', '11011101', '11011110', '11011111', '11100000',
        '11100001', '11100010', '11100011', '11100100', '11100101', '11100110', '11100111', '11101000',
        '11101001', '11101010', '11101011', '11101100', '11101101', '11101110', '11101111', '11110000',
        '11110001', '11110010', '11110011', '11110100', '11110101', '11110110', '11110111', '11111000',
        '11111001', '11111010', '11111011', '11111100', '11111101', '11111110', '11111111'
      ];
      // Act
      List<String> actualAsciiList = actualBinaryList.map(BinaryUtils.convertBinaryToAscii).toList();

      // Assert
      List<String> expectedAsciiList = <String>[
        '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\x08', '\x09', '\x0A', '\x0B', '\x0C',
        '\x0D', '\x0E', '\x0F', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18',
        '\x19', '\x1A', '\x1B', '\x1C', '\x1D', '\x1E', '\x1F', '\x20', '!', '"', '#', r'$', '%', '&', "'",
        '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':',
        ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', r'\', ']', '^', '_', '`',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
        't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7F', '', '', '', '', '',
        '', '', '', '', '', '', '', '', '', '', '', '', '', '',
        '', '', '', '', '', '', '', '', '', '', '', '', '', '\xa0',
        '¡', '¢', '£', '¤', '¥', '¦', '§', '¨', '©', 'ª', '«', '¬', '­', '®', '¯', '°', '±', '²', '³',
        '´', 'µ', '¶', '·', '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ',
        'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù',
        'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì',
        'í', 'î', 'ï', 'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ',
      ];

      expect(actualAsciiList, expectedAsciiList);
      // @formatter:on
    });

    test('Should parse binary representation of String containing all ASCII characters into human-readable String', () {
      // Arrange
      String actualBinaryString =
          '000000010000001000000011000001000000010100000110000001110000100000001001000010100000101100001100000011010000111000001111000100000001000100010010000100110001010000010101000101100001011100011000000110010001101000011011000111000001110100011110000111110010000000100001001000100010001100100100001001010010011000100111001010000010100100101010001010110010110000101101001011100010111100110000001100010011001000110011001101000011010100110110001101110011100000111001001110100011101100111100001111010011111000111111010000000100000101000010010000110100010001000101010001100100011101001000010010010100101001001011010011000100110101001110010011110101000001010001010100100101001101010100010101010101011001010111010110000101100101011010010110110101110001011101010111100101111101100000011000010110001001100011011001000110010101100110011001110110100001101001011010100110101101101100011011010110111001101111011100000111000101110010011100110111010001110101011101100111011101111000011110010111101001111011011111000111110101111110011111111000000010000001100000101000001110000100100001011000011010000111100010001000100110001010100010111000110010001101100011101000111110010000100100011001001010010011100101001001010110010110100101111001100010011001100110101001101110011100100111011001111010011111101000001010000110100010101000111010010010100101101001101010011110101000101010011010101010101011101011001010110110101110101011111011000010110001101100101011001110110100101101011011011010110111101110001011100110111010101110111011110010111101101111101011111111000000110000011100001011000011110001001100010111000110110001111100100011001001110010101100101111001100110011011100111011001111110100001101000111010010110100111101010011010101110101101101011111011000110110011101101011011011110111001101110111011110110111111110000011100001111000101110001111100100111001011110011011100111111010001110100111101010111010111110110011101101111011101110111111110000111100011111001011110011111101001111010111110110111101111111100011111001111110101111101111111100111111011111111011111111';

      // Act
      String actualHumanReadableString = BinaryUtils.convertBinaryToAscii(actualBinaryString);

      // Assert
      String expectedHumanReadableString =
          '\x01\x02\x03\x04\x05\x06\x07\b\t\n\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F\x20!"#\$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xa0¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ';

      expect(actualHumanReadableString, expectedHumanReadableString);
    });
  });

  group('Test of BinaryUtils.convertAsciiToBinary()', () {
    test('Should parse each ASCII letter into 8-bit binary', () {
      // Arrange
      // @formatter:off
      List<String> actualAsciiList = <String>[
        '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\x08', '\x09', '\x0A', '\x0B', '\x0C',
        '\x0D', '\x0E', '\x0F', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18',
        '\x19', '\x1A', '\x1B', '\x1C', '\x1D', '\x1E', '\x1F', '\x20', '!', '"', '#', r'$', '%', '&', "'",
        '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':',
        ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', r'\', ']', '^', '_', '`',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
        't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7F', '', '', '', '', '',
        '', '', '', '', '', '', '', '', '', '', '', '', '', '',
        '', '', '', '', '', '', '', '', '', '', '', '', '', '\xa0',
        '¡', '¢', '£', '¤', '¥', '¦', '§', '¨', '©', 'ª', '«', '¬', '­', '®', '¯', '°', '±', '²', '³',
        '´', 'µ', '¶', '·', '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ',
        'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù',
        'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì',
        'í', 'î', 'ï', 'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ',
      ];

      // Act
      List<String> actualBinaryListString = actualAsciiList.map(BinaryUtils.convertAsciiToBinary).toList();

      // Assert
      List<String> expectedBinaryList = <String>[
        '00000001', '00000010', '00000011', '00000100', '00000101', '00000110', '00000111', '00001000',
        '00001001', '00001010', '00001011', '00001100', '00001101', '00001110', '00001111', '00010000',
        '00010001', '00010010', '00010011', '00010100', '00010101', '00010110', '00010111', '00011000',
        '00011001', '00011010', '00011011', '00011100', '00011101', '00011110', '00011111', '00100000',
        '00100001', '00100010', '00100011', '00100100', '00100101', '00100110', '00100111', '00101000',
        '00101001', '00101010', '00101011', '00101100', '00101101', '00101110', '00101111', '00110000',
        '00110001', '00110010', '00110011', '00110100', '00110101', '00110110', '00110111', '00111000',
        '00111001', '00111010', '00111011', '00111100', '00111101', '00111110', '00111111', '01000000',
        '01000001', '01000010', '01000011', '01000100', '01000101', '01000110', '01000111', '01001000',
        '01001001', '01001010', '01001011', '01001100', '01001101', '01001110', '01001111', '01010000',
        '01010001', '01010010', '01010011', '01010100', '01010101', '01010110', '01010111', '01011000',
        '01011001', '01011010', '01011011', '01011100', '01011101', '01011110', '01011111', '01100000',
        '01100001', '01100010', '01100011', '01100100', '01100101', '01100110', '01100111', '01101000',
        '01101001', '01101010', '01101011', '01101100', '01101101', '01101110', '01101111', '01110000',
        '01110001', '01110010', '01110011', '01110100', '01110101', '01110110', '01110111', '01111000',
        '01111001', '01111010', '01111011', '01111100', '01111101', '01111110', '01111111', '10000000',
        '10000001', '10000010', '10000011', '10000100', '10000101', '10000110', '10000111', '10001000',
        '10001001', '10001010', '10001011', '10001100', '10001101', '10001110', '10001111', '10010000',
        '10010001', '10010010', '10010011', '10010100', '10010101', '10010110', '10010111', '10011000',
        '10011001', '10011010', '10011011', '10011100', '10011101', '10011110', '10011111', '10100000',
        '10100001', '10100010', '10100011', '10100100', '10100101', '10100110', '10100111', '10101000',
        '10101001', '10101010', '10101011', '10101100', '10101101', '10101110', '10101111', '10110000',
        '10110001', '10110010', '10110011', '10110100', '10110101', '10110110', '10110111', '10111000',
        '10111001', '10111010', '10111011', '10111100', '10111101', '10111110', '10111111', '11000000',
        '11000001', '11000010', '11000011', '11000100', '11000101', '11000110', '11000111', '11001000',
        '11001001', '11001010', '11001011', '11001100', '11001101', '11001110', '11001111', '11010000',
        '11010001', '11010010', '11010011', '11010100', '11010101', '11010110', '11010111', '11011000',
        '11011001', '11011010', '11011011', '11011100', '11011101', '11011110', '11011111', '11100000',
        '11100001', '11100010', '11100011', '11100100', '11100101', '11100110', '11100111', '11101000',
        '11101001', '11101010', '11101011', '11101100', '11101101', '11101110', '11101111', '11110000',
        '11110001', '11110010', '11110011', '11110100', '11110101', '11110110', '11110111', '11111000',
        '11111001', '11111010', '11111011', '11111100', '11111101', '11111110', '11111111'
      ];
      // @formatter:on
      expect(actualBinaryListString, expectedBinaryList);
    });

    test('Should parse human-readable String containing all ASCII characters into binary representation of this String', () {
      // Arrange
      String actualHumanReadableString =
          '\x01\x02\x03\x04\x05\x06\x07\b\t\n\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F\x20!"#\$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xa0¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ';

      // Act
      String actualBinaryString = BinaryUtils.convertAsciiToBinary(actualHumanReadableString);

      // Assert
      String expectedBinaryString =
          '000000010000001000000011000001000000010100000110000001110000100000001001000010100000101100001100000011010000111000001111000100000001000100010010000100110001010000010101000101100001011100011000000110010001101000011011000111000001110100011110000111110010000000100001001000100010001100100100001001010010011000100111001010000010100100101010001010110010110000101101001011100010111100110000001100010011001000110011001101000011010100110110001101110011100000111001001110100011101100111100001111010011111000111111010000000100000101000010010000110100010001000101010001100100011101001000010010010100101001001011010011000100110101001110010011110101000001010001010100100101001101010100010101010101011001010111010110000101100101011010010110110101110001011101010111100101111101100000011000010110001001100011011001000110010101100110011001110110100001101001011010100110101101101100011011010110111001101111011100000111000101110010011100110111010001110101011101100111011101111000011110010111101001111011011111000111110101111110011111111000000010000001100000101000001110000100100001011000011010000111100010001000100110001010100010111000110010001101100011101000111110010000100100011001001010010011100101001001010110010110100101111001100010011001100110101001101110011100100111011001111010011111101000001010000110100010101000111010010010100101101001101010011110101000101010011010101010101011101011001010110110101110101011111011000010110001101100101011001110110100101101011011011010110111101110001011100110111010101110111011110010111101101111101011111111000000110000011100001011000011110001001100010111000110110001111100100011001001110010101100101111001100110011011100111011001111110100001101000111010010110100111101010011010101110101101101011111011000110110011101101011011011110111001101110111011110110111111110000011100001111000101110001111100100111001011110011011100111111010001110100111101010111010111110110011101101111011101110111111110000111100011111001011110011111101001111010111110110111101111111100011111001111110101111101111111100111111011111111011111111';
      expect(actualBinaryString, expectedBinaryString);
    });
  });
  group('Test of BinaryUtils.parseIntToPaddedBinary()', () {
    test('Should return 24 as binary padded with 20 leading zeros for 26 digits', () {
      // Arrange
      int actualValue = 24;
      int actualDigits = 26;

      // Act
      String actualPaddedBinary = BinaryUtils.parseIntToPaddedBinary(actualValue, actualDigits);

      // Assert
      String expectedPaddedBinary = '00000000000000000000011000';
      expect(actualPaddedBinary, expectedPaddedBinary);
    });

    test('Should return 26 as binary padded with 18 leading zeros for 24 digits', () {
      // Arrange
      int actualValue = 26;
      int actualDigits = 24;

      // Act
      String actualPaddedBinary = BinaryUtils.parseIntToPaddedBinary(actualValue, actualDigits);

      // Assert
      String expectedPaddedBinary = '000000000000000000011010';
      expect(actualPaddedBinary, expectedPaddedBinary);
    });

    test('Should return 26 as binary padded with 20 leading zeros for 26 digits', () {
      // Arrange
      int actualValue = 26;
      int actualDigits = 26;

      // Act
      String actualPaddedBinary = BinaryUtils.parseIntToPaddedBinary(actualValue, actualDigits);

      // Assert
      String expectedPaddedBinary = '00000000000000000000011010';
      expect(actualPaddedBinary, expectedPaddedBinary);
    });
  });
}